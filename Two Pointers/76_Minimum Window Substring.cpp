/*
思想是:
第一步:先移动右指针扩大窗口,去包含那些需要的元素
第二步:如果窗口内包含了所有的元素,再尝试移动左指针,以求最小空间
第三步:如果移动左指针后,窗口内反而缺少元素了,那就回到第一步移动右指针.
实现:
*判断是否时需要的元素:用一个bool类型的数组flag,需要的为true.其余为false
*判断当前是否还缺少某个元素:用一个int类型的数组need,需要的元素初始值为1,窗口内每包含一个该元素就减一.
*判断窗口内元素是否包含全了:
    1.用一个count变量记数,need里每从1变为0,count就+1,其他情况count不加1.
    2.当count==t.size()即所需元素的个数时,说明齐全了.
    3.count和need是一起变的.如果每次都靠遍历查找need是否所有元素都<=0,时间消耗太大,用count就很好~
*记录最小空间:
    1.在开始移动右指针前,要先记录下当前的左右指针位置r-l+1为临时最小空间
    2.这样尝试左指针l后,如果窗口内还是有所有所需元素,则临时空间继续变小
    3.如果丢失了所需元素,那之前的最小空间已经保存了,只要继续移动右指针r去寻找下一个满足的窗口
    4.如果丢失了所需元素,就要让count-1,说明缺了一个元素
    5.如此反复比较不同的满足条件窗口和最小空间的大小,最后得到一个真正的最小的空间
*/
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(128,0);        //记录当前窗口还缺少的字符数.某字符的need值=1表示缺少1个该字符,若=-1则表示当前窗口有2个该字符,多一个.
        vector<bool> flag(128,false);   //记录需要的字符是哪些
        for(int i=0;i<t.size();++i){
            flag[t[i]] = true;          //字符在计算机里是按整数储存的,按照ascall码,共有128个.
            ++need[t[i]];
        }
        int l=0,r=0; //窗口的左右2指针
        int count=0; //记录窗口内已含有多少个所需元素.
        int min_size=s.size()+1; //设置一个最小窗口大小
        int min_l = 0;           //最小窗口时的左指针位置
        for(;r<s.size();++r){
            if(flag[s[r]]){
                if(--need[s[r]]>=0){   //need中某字符数如果=1说明还缺,=0说明不缺正好,<0说明之前已经有该元素,count不用再++
                    ++count;
                }
            }
            //当count==t中元素个数,说明窗口中已经包含全了所需元素
            //这时就要为了尽可能小,移动左指针
            while(count==t.size()){
                //先记录当前最小窗口大小
                if(r-l+1<min_size){
                    min_l=l;
                    min_size=r-l+1;
                }
                //如果l右移,相当于当前值被删除,所以如果当前窗口内正好只有1个该元素,那么count就是-1,表示又缺少了一个
                if((flag[s[l]]) && ++need[s[l]]>0){
                    count--;
                }
                ++l;
            }
        }
        return min_size>s.size()?"":s.substr(min_l,min_size);
    }
};
